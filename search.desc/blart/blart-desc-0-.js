searchState.loadedDescShard("blart", 0, "Adaptive radix trie implementation\nAny type implementing <code>AsBytes</code> can be decomposed into bytes.\nThe bytestring type that the <code>D</code> is converted to.\nTrait representing a reversible conversion from a type to …\nThis type implements a <code>BytesMapping</code> for tuples of types, …\nThis type implements a <code>BytesMapping</code> that preserves the …\nA container for the bytestring that is produced from …\nThis trait is used to mark types which have a byte …\nThis trait is used to mark types where the lexicographic …\nThis struct represents a conversion of <strong>signed integers</strong> to …\nThis struct represents a conversion of <strong>IP addresses</strong> (V4 …\nThis struct represents a conversion of <strong>unsigned integers</strong> …\nAn ordered map based on an adaptive radix tree.\nThe allocator which will be used to alloc and dealloc tree …\nView the current value as a byte array.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert the bytestring type back into the domain type\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nModule containing implementations of the <code>TreeMap</code> and …\nThe number of entries present in the tree.\nTrie node representation and manipulation\nModule containing copies of Rust standard library unstable …\nA pointer to the tree root, if present.\nA tagged pointer is a pointer (concretely a memory …\nConvert the domain type into the bytestring type\nAn implementation of <code>Allocator</code> can allocate, grow, shrink, …\nThe global memory allocator.\nAttempts to allocate a block of memory.\nBehaves like <code>allocate</code>, but also ensures that the returned …\nCreates a “by reference” adapter for this instance of …\nDeallocates the memory referenced by <code>ptr</code>.\nReturns the argument unchanged.\nAttempts to extend the memory block.\nBehaves like <code>grow</code>, but also ensures that the new contents …\nCalls <code>U::from(self)</code>.\nAttempts to shrink the memory block.\nAn implementation of <code>Allocator</code> can allocate, grow, shrink, …\nThe global memory allocator.\nAttempts to allocate a block of memory.\nBehaves like <code>allocate</code>, but also ensures that the returned …\nCreates a “by reference” adapter for this instance of …\nDeallocates the memory referenced by <code>ptr</code>.\nAttempts to extend the memory block.\nBehaves like <code>grow</code>, but also ensures that the new contents …\nAttempts to shrink the memory block.\nAny type implementing <code>AsBytes</code> can be decomposed into bytes.\nThis trait is used to mark types which have a byte …\nThis trait is used to mark types where the lexicographic …\nView the current value as a byte array.\nThe bytestring type that the <code>D</code> is converted to.\nTrait representing a reversible conversion from a type to …\nThis type implements a <code>BytesMapping</code> for tuples of types, …\nThis type implements a <code>BytesMapping</code> that preserves the …\nA container for the bytestring that is produced from …\nThis struct represents a conversion of <strong>signed integers</strong> to …\nThis struct represents a conversion of <strong>IP addresses</strong> (V4 …\nThis struct represents a conversion of <strong>unsigned integers</strong> …\nConvert the bytestring type back into the domain type\nTake the byte representation and convert it back to the …\nSafety\nTransform a value into its bytes representation\nConvert the domain type into the bytestring type\nCreated a new instance of <code>Mapped</code> starting from the byte …\nModule containing implementations of the <code>TreeMap</code> and …\nThis is the default number of bytes that are used in each …\nAn ordered map based on an adaptive radix tree.\nThe allocator which will be used to alloc and dealloc tree …\nReturns a reference to the underlying allocator.\nMoves all elements from other into self, leaving other …\nRemove the given delete point from the tree, fixing up the …\nAdd the given insert point to the tree, fixing up the …\nClear the map, removing all elements.\nReturns true if the map contains a value for the specified …\nGets the given key’s corresponding entry in the map for …\nCreates an iterator that visits elements (key-value pairs) …\nReturns the first key-value pair in the map. The key in …\nReturns the argument unchanged.\nConstructs a <code>TreeMap</code> from a raw node pointer.\nConstructs a <code>TreeMap</code> from a raw node pointer and the given …\nConstructs a <code>TreeMap</code> from a raw node pointer and the given …\nConstructs a <code>TreeMap</code> from a raw node pointer.\nMakes a fuzzy search in the tree by <code>key</code>, returning all …\nMakes a fuzzy search in the tree by <code>key</code>, returning all …\nReturns a reference to the value corresponding to the key.\nReturns the key-value pair corresponding to the supplied …\nReturns a mutable reference to the value corresponding to …\nInsert a key-value pair into the map.\nCalls <code>U::from(self)</code>.\nCreates a consuming iterator visiting all the keys, in …\nConsume the tree, returning a raw pointer to the root node.\nConsume the tree, returning a raw pointer to the root node …\nCreates a consuming iterator visiting all the values, in …\nReturns <code>true</code> if the map contains no elements.\nGets an iterator over the entries of the map, sorted by …\nGets a mutable iterator over the entries of the map, …\nGets an iterator over the keys of the map, in sorted order.\nReturns the last key-value pair in the map. The key in …\nReturns the number of elements in the map.\nCreate a new, empty <code>TreeMap</code> with the default number of …\nCreate a new, empty <code>TreeMap</code> with the default number of …\nThe number of entries present in the tree.\nRemoves and returns the first element in the map. The key …\nRemoves and returns the last element in the map. The key …\nGets an iterator over the entries of the map that start …\nTries to get the given key’s corresponding prefix entry …\nReturns a reference to the value corresponding to the leaf …\nReturns the key-value pair corresponding to the value of …\nReturns the key-value pair, with the value as a mutable …\nReturns a mutable reference to the value corresponding to …\nForce inserts a key-value pair into the map.\nGets a mutable iterator over the entries of the map that …\nConstructs a double-ended iterator over a sub-range of …\nConstructs a mutable double-ended iterator over a …\nRemoves a key from the map, returning the value at the key …\nRemoves a key from the map, returning the stored key and …\nRetains only the elements specified by the predicate.\nSplits the collection into two at the given key. Returns …\nA pointer to the tree root, if present.\nTries to get the given key’s corresponding entry in the …\nInserts a key-value pair into the map.\nGets an iterator over the values of the map, in order by …\nGets a mutable iterator over the values of the map, in …\nCreate a new, empty <code>TreeMap</code> with a non-default node prefix …\nCreate a new, empty <code>TreeMap</code> with a non-default node prefix …\nA view into a single entry in a map, which may either be …\nA view into an occupied entry in a <code>TreeMap</code>.\nA view into an occupied entry in a <code>TreeMap</code>. It is part of …\nA view into a vacant entry in a <code>TreeMap</code>.\nA view into a vacant entry in a <code>TreeMap</code>. It is part of the …\nProvides in-place mutable access to an occupied entry …\nThe point in the tree that would be removed if requested.\nThis function will adjust the parent pointers in the …\nGets a reference to the value in the entry.\nGets a mutable reference to the value in the entry.\nSets the value of the entry, and returns the entry’s old …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry with the <code>VacantEntry</code>’s key, …\nSets the value of the entry, and returns an <code>OccupiedEntry</code>.\nTake ownership of the key.\nConverts the <code>OccupiedEntry</code> into a mutable reference to the …\nGets a reference to the key in the entry.\nGets a reference to the key that would be used when …\nReturns a reference to this entry’s key.\nUsed for the removal\nEnsures a value is in the entry by inserting the default …\nSimilar to <code>Entry::or_default</code> but yields an <code>OccupiedEntry</code>\nEnsures a value is in the entry by inserting the default …\nSimilar to <code>Entry::or_insert</code> but yields an <code>OccupiedEntry</code>\nEnsures a value is in the entry by inserting the result of …\nSimilar to <code>Entry::or_insert_with</code> but yields an …\nEnsures a value is in the entry by inserting, if empty, …\nSimilar to <code>Entry::or_insert_with_key</code> but yields an …\nTakes the value of the entry out of the map, and returns …\nTakes the entry out of the map and returns it.\nThis module contains types and functions relating to …\nAn iterator which uses a closure to determine if an …\nCreate a new range iterator over the given tree, starting …\nTest the given leaf node against the predicate and if it …\nAn iterator over all the <code>LeafNode</code>s within a specific edit …\nAn iterator over all the <code>LeafNode</code>s within a specific edit …\nSAFETY: <code>old</code> and <code>new</code> must have the same length, and be &gt;= 1\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSAFETY: This function should only be called after …\nSAFETY: This function should only be called after …\nSAFETY: <code>old_row</code> length == <code>new_row</code> length\nAn owning iterator over the entries of a <code>TreeMap</code>.\nAn owning iterator over the keys of a <code>TreeMap</code>.\nAn owning iterator over the values of a <code>TreeMap</code>.\nAn iterator over all the <code>LeafNode</code>s\nAn iterator over all the <code>LeafNode</code>s\nAn iterator over all the <code>LeafNode</code>s\nAn iterator over all the <code>LeafNode</code>s\nAn iterator over all the <code>LeafNode</code>s\nCreate a new iterator that will visit all leaf nodes …\nCreate a new iterator that will visit all leaf nodes …\nCreate a new iterator that will visit all leaf nodes …\nCreate a new iterator that will visit all leaf nodes …\nCreate a new iterator that will visit all leaf nodes …\nAn iterator over a range of entries that all have the same …\nA mutable iterator over a range of entries that all have …\nCreate a new prefix iterator over the given tree, the …\nCreate a new prefix iterator over the given tree, the …\nThis variant means the search terminated at an inner node.\nThis struct contains details of where and why the search …\nThese are search termination reasons specific to inner …\nThis variant means the search terminated at a leaf node.\nThis variant means the search terminated in an inner node, …\nNo value.\nThis variant means the search terminated in a mismatched …\nAn iterator over a sub-range of entries in a <code>TreeMap</code>.\nA mutable iterator over a sub-range of entries in a <code>TreeMap</code>…\nSome value of type <code>T</code>.\nThis enum provides the different cases of search result …\nThe number of bytes of the key that were consumed, not …\nThis function searches a trie for the smallest/largest …\nFind the node (inner or leaf) that is identified by the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new range iterator over the given tree, starting …\nCreate a new range iterator over the given tree, starting …\nThis is a comparison from the full prefix of the inner …\nThis is a pointer to the inner node where search stopped.\nThis field indicates why the search stopped in the inner …\nPanic if the given range bounds\nThe ordering of the leaf key bytes relative to the search …\nThe leaf node pointer where search terminated.\nAn iterator over a subtree in a <code>TreeMap</code>.\nA mutable iterator over a range of entries that all have …\nCreate a new iterator over the given subtree, the iterator …\nCreate a new iterator over the given subtree, the iterator …\nAn occupied entry where the key is a prefix of existing …\nA view into an occupied subtree in a <code>TreeMap</code>.\nAn occupied entry where key matched completely.\nA view into an occupied prefix entry in a <code>TreeMap</code>.\nA view into a prefixed entry in a map, which may either be …\nAn occupied entry of a prefix insert operation.\nA view into a vacant entry in a <code>TreeMap</code>.\nGets a reference to the underlying value if there is only …\nGets a reference to the underlying value if there is only …\nGets a reference to the underlying key if there is only a …\nGets a reference to the underlying key if there is only a …\nGets a reference to the underlying key if there is only a …\nGets a reference to the underlying key and a mutable …\nGets a mutable reference to the underlying value if there …\nGets a mutable reference to the underlying value if there …\nErase the subtree and insert the value with the previously …\nSets the value of the entry.\nErase the subtree and insert the value with the previously …\nSets the value of the entry.\nSets the value of the entry, and returns an <code>OccupiedEntry</code>.\nReturns an iterator over all key value pairs that would be …\nReturns a mutable iterator over all key value pairs that …\nReturns a reference to the key that will overwrite the …\nReturns a reference to the key that got used for the …\nReturns a reference to the key that got used for the …\nEnsures a leaf is in the entry by inserting the default …\nSimilar to <code>PrefixEntry::or_default</code> but yields an …\nEnsures a leaf is in the entry by inserting the default if …\nSimilar to <code>PrefixEntry::or_insert</code> but yields an …\nEnsures a leaf is in the entry by inserting the result of …\nEnsures a leaf is in the entry by inserting, if empty or …\nSimilar to <code>PrefixEntry::or_insert_with_key</code> but yields an …\nThis is the default number of bytes that are used in each …\nA view into a single entry in a map, which may either be …\nAn iterator which uses a closure to determine if an …\nAn iterator over all the <code>LeafNode</code>s within a specific edit …\nAn iterator over all the <code>LeafNode</code>s within a specific edit …\nAn occupied entry where the key is a prefix of existing …\nA view into an occupied subtree in a <code>TreeMap</code>.\nAn owning iterator over the entries of a <code>TreeMap</code>.\nAn owning iterator over the keys of a <code>TreeMap</code>.\nAn owning iterator over the values of a <code>TreeMap</code>.\nAn iterator over all the <code>LeafNode</code>s\nAn iterator over all the <code>LeafNode</code>s\nAn iterator over all the <code>LeafNode</code>s\nAn occupied entry where key matched completely.\nA view into an occupied entry in a <code>TreeMap</code>.\nA view into an occupied prefix entry in a <code>TreeMap</code>.\nA view into an occupied entry in a <code>TreeMap</code>. It is part of …\nAn iterator over a range of entries that all have the same …\nA view into a prefixed entry in a map, which may either be …\nA mutable iterator over a range of entries that all have …\nAn occupied entry of a prefix insert operation.\nAn iterator over a sub-range of entries in a <code>TreeMap</code>.\nA mutable iterator over a sub-range of entries in a <code>TreeMap</code>…\nAn iterator over a subtree in a <code>TreeMap</code>.\nA mutable iterator over a range of entries that all have …\nAn ordered map based on an adaptive radix tree.\nA view into a vacant entry in a <code>TreeMap</code>.\nA view into a vacant entry in a <code>TreeMap</code>.\nA view into a vacant entry in a <code>TreeMap</code>. It is part of the …\nAn iterator over all the <code>LeafNode</code>s\nAn iterator over all the <code>LeafNode</code>s\nThe allocator which will be used to alloc and dealloc tree …\nThe point in the tree that would be removed if requested.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUsed for the removal\nThe number of entries present in the tree.\nA pointer to the tree root, if present.\nThis struct represents a successful match against a prefix …\nThis variant indicates a tree with a non-leaf root, and …\nAn enum that encapsulates pointers to every type of …\nAn enum that encapsulates pointers to every type of <code>Node</code>\nRepresents a prefix mismatch when looking at the entire …\nThe type of the next larger node type.\nCommon methods implemented by all inner node.\nNode that references between 5 and 16 children\nNode that references between 49 and 256 children\nNode that references between 2 and 4 children\nNode that references between 17 and 49 children\nNode type that has a compact representation for key bytes …\nIterator type for an <code>InnerNodeCompressed</code>\nThe type of the iterator over all children of the inner …\nThe key type carried by the leaf nodes\nNode that contains a single value\nNode that contains a single leaf value.\nNode that contains a single value\nAll nodes which contain a runtime tag that validates their …\nNode that references between 5 and 16 children\nNode that references between 5 and 16 children\nNode that references between 5 and 16 children\nNode that references between 49 and 256 children\nNode that references between 49 and 256 children\nNode that references between 49 and 256 children\nNode that references between 2 and 4 children\nNode that references between 2 and 4 children\nNode that references between 2 and 4 children\nNode that references between 17 and 49 children\nNode that references between 17 and 49 children\nNode that references between 17 and 49 children\nA pointer to a <code>Node</code>.\nThe representation of inner nodes\nThis variant covers all other tree cases, where the leaf …\nAn opaque pointer to a <code>Node</code>.\nRepresents a prefix mismatch when looking only at the …\nRepresents a prefix mismatch when looking only at the …\nThis struct represents a successful match against a prefix …\nA restricted index only valid from 0 to LIMIT - 1.\nThis variant indicates a tree with only a single leaf node …\nThe type of the next smaller node type.\nThe runtime type of the node.\nThis enum represents different kinds of tree paths …\nThis type is used to track the parent and grandparent when …\nThe error type returned when attempting to construct an …\nThe value type carried by the leaf nodes\nThis flag will be true if the …\nTest the given key against the inner node header prefix by …\nAn array that maps key bytes (as the index) to the index …\nAn array that directly maps a key byte (as index) to a …\nFor each element in this array, it is assumed to be …\nAn array that contains the child data.\nAn array that contains the child data.\nAn array that contains the child data.\nCreate an empty <code>InnerNode</code>, with no children and no prefix\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>InnerNode</code> using a <code>Header</code>\nCreate a new <code>InnerNode</code> using <code>prefix</code> as the node prefix and …\nGrow this node into the next larger class, copying over …\nGet the <code>Header</code> from the <code>InnerNode</code>\nThe common node fields.\nThe common node fields.\nThe common node fields.\nThe common node fields.\nThe common node fields.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if this node has no more space to store …\nCreate an iterator over all <code>(key bytes, child pointers)</code> in …\nThe full key that the <code>value</code> was stored with.\nAn array that contains single key bytes in the same index …\nAn array that contains single key bytes in the same index …\nAn array that contains single key bytes in the same index …\nPointer to the leaf if the prefix was reconstructed\nSearch through this node for a child node that corresponds …\nCompares the compressed path of a node with the key and …\nHow many bytes were matched\nHow many bytes were matched\nHow many bytes were matched\nHow many bytes were matched\nHow many bytes were matched\nReturns the maximum child pointer from this node and it’…\nReturns the minimum child pointer from this node and it’…\nPointer to the next leaf node in the trie. If the value is …\nTrie node lookup and manipulation\nTest the given key against the inner node header prefix by …\nValue of the byte that made it not match\nValue of the byte that made it not match.\nPointer to the previous leaf node in the trie. If the …\nCreate an iterator over a subset of …\nRead the prefix as a whole, by reconstructing it if …\nAttempt to remove a child pointer at the key fragment from …\nTrie node representation\nShrink this node into the next smaller class, copying over …\nThe leaf value.\nUtilities for inspecting the trie structure.\nWrite a child pointer with key fragment to this inner node.\nThe key byte which selects the leaf node when used as …\nThe key byte which selects the leaf node when used as …\nA pointer to the grandparent node.\nA pointer to the root node of the tree.\nA pointer to the parent node.\nThe key byte which selects the parent node when used as …\nThis struct represents a simple sort-iterator over leaves …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>RawIterator</code> with the given starting and ending\nIf the iterator is not empty, return the next leaf pointer …\nIf the iterator is not empty, return the next leaf pointer …\nThis module contains the implementation of <code>clone()</code> for the …\nThe result of cloning a trie\nClone the given trie and all the key-values paired …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe last leaf in the trie, aka the leaf with the maximum …\nThe first leaf in the trie, aka the leaf with the minimum …\nThe new root node of the trie\nThis function will read an <code>InnerNode</code> and place all …\nDeallocate all the leaf nodes in the linked list starting …\nDeallocate the given node and all children of the given …\nDeallocate the given node and all children of the given …\nThis struct represents a location in the trie that can be …\nThe results of a successful delete operation\nHandle the logic of deleting a leaf node from the tree, …\nThe leaf node that was successfully deleted.\nFind the maximum leaf in the tree and return the …\nFind the minimum leaf in the tree and return the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nDelete the given non-root leaf node.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe node to delete.\nThe new root node for the tree, after the delete has been …\nThe path to the leaf node to delete.\nRemove a child node from the given inner node, return the …\nSearch in the given tree for the leaf node to delete, …\nExit the operation without running subsequent phases.\nMove on to the next phase of the operation as normal.\nExact match of the leaf was found\nThe type of insert\nThis struct contains the results from searching for an …\nAttempted to insert a key which was a prefix of an …\nThe results of a successful tree insert\nAn insert where the search terminated at an existing inner …\nAn insert where an inner node had a differing prefix from …\nThis variant indicates that a new parent node was …\nThis variant indicates that there was no replacement of …\nContains all the information needed to overwrite a certain …\nThis enum contains the results from searching for a …\nThe results of a successful prefix insert.\nAn insert where the node to be added matched all the way …\nThis function will use <code>InsertPoint</code> information to insert …\nThis function will use <code>PrefixInsertPoint</code> information to …\nThis function will use <code>OverwritePoint</code> information to …\nThe inserted key\nThe existing leaf referenced by the insert key, if present\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe kind of operation that needs to be performed to insert …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe number of bytes that were read from the key to find …\nThe number of bytes that were read from the key to find …\nPointer to the leaf\nThe new tree root after the successful insert\nThe pointer to the node that will be overwritten.\nThis field details what kind of changes happened to the …\nWrite a new child node to an inner node at the specified …\nThe path to point where the new leaf will be inserted.\nThe path to point where the new leaf will be inserted.\nCurrent root of the tree, used in the apply\nCurrent root of the tree, used in the apply\nPerform an iterative search for the insert point for the …\nPerform an iterative search for the insert point for the …\nCheck that the given inner node’s prefix matches the …\nA pointer to the existing inner node which will be updated …\nA pointer to the leaf node that will be split\nA pointer to the leaf node that will be split\nData about the matching if the prefix\nA pointer to the inner node which had a mismatched prefix\nThe key byte used to select the newly inserted leaf node\nA pointer to the newly allocated parent node.\nThis variant indicates that at least one <code>prefix_*_match</code> …\nThis variant indicates that all <code>prefix_*_match</code> calls have …\nThis enum is used to track the <code>match_*_prefix</code> state as a …\nFor the given <code>InnerNode</code>, check the node prefix, then …\nThis function will compare the key bytes against the key …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis function will test given leaf key is a prefix of the …\nThis function will choose between different “match prefix…\nThis function will test the key bytes against the key in …\nSearch in the given tree for the value stored with the key …\nSearch in the given tree for the value stored with the …\nSearch for the leaf with the maximum key, by lexicographic …\nSearch for the leaf with the minimum key, by lexicographic …\nThis struct represents a successful match against a prefix …\nThis variant indicates a tree with a non-leaf root, and …\nAn enum that encapsulates pointers to every type of …\nAn enum that encapsulates pointers to every type of <code>Node</code>\nRepresents a prefix mismatch when looking at the entire …\nThe type of the next larger node type.\nCommon methods implemented by all inner node.\nThe type of the iterator over all children of the inner …\nThe key type carried by the leaf nodes\nNode that contains a single value\nNode that contains a single leaf value.\nNode that contains a single value\nAll nodes which contain a runtime tag that validates their …\nNode that references between 5 and 16 children\nNode that references between 5 and 16 children\nNode that references between 5 and 16 children\nNode that references between 49 and 256 children\nNode that references between 49 and 256 children\nNode that references between 49 and 256 children\nNode that references between 2 and 4 children\nNode that references between 2 and 4 children\nNode that references between 2 and 4 children\nNode that references between 17 and 49 children\nNode that references between 17 and 49 children\nNode that references between 17 and 49 children\nA pointer to a <code>Node</code>.\nThe representation of inner nodes\nNo value.\nThis variant covers all other tree cases, where the leaf …\nAn opaque pointer to a <code>Node</code>.\nA placeholder type that has the required amount of …\nRepresents a prefix mismatch when looking only at the …\nThis type alias represents an optional pointer to a leaf …\nRepresents a prefix mismatch when looking only at the …\nThis struct represents a successful match against a prefix …\nThis variant indicates a tree with only a single leaf node …\nThe type of the next smaller node type.\nSome value of type <code>T</code>.\nThe runtime type of the node.\nThis enum represents different kinds of tree paths …\nThis type is used to track the parent and grandparent when …\nThe value type carried by the leaf nodes\nAllocate the given <code>Node</code> on the <code>alloc::alloc::Global</code> heap …\nThis flag will be true if the …\nReturns a unique mutable reference to the key and value of …\nReturns a unique mutable reference to the key and value of …\nReturns a shared reference to the key and value of the …\nReturns a unique mutable reference to the node.\nReturns a shared reference to the value.\nReturns a unique mutable reference to the key and value of …\nReturns a unique mutable reference to the key and value of …\nTest the given key against the inner node header prefix by …\nReturn the range of number of children that each node type …\nCreate a non-opaque node pointer that will eliminate …\nCreate a copy of this leaf node with the sibling …\nDeallocate a <code>Node</code> object created with the …\nCreate an empty <code>InnerNode</code>, with no children and no prefix\nReturn mutable references to the key and value contained …\nReturn shared references to the key and value contained by …\nComplete the tree search and return a <code>TreePath</code> which has …\nReturns the argument unchanged.\nCreate a new <code>InnerNode</code> using a <code>Header</code>\nCreate a new <code>InnerNode</code> using <code>prefix</code> as the node prefix and …\nConverts a u8 value to a <code>NodeType</code>\nGrow this node into the next larger class, copying over …\nDifferent header type\nGet the <code>Header</code> from the <code>InnerNode</code>\nGet a mutable reference to the header if the underlying …\nGet a mutable reference to the header, this doesn’t …\nGet a shared reference to the header, this doesn’t check …\nInsert the leaf node pointed to by <code>this_ptr</code> into the …\nInsert the leaf node pointed to by <code>this_ptr</code> into the …\nCalls <code>U::from(self)</code>.\nConsume the leaf node and return a tuple of the key and …\nReturn <code>true</code> if this Node_ pointer points to the specified …\nReturns true if this node has no more space to store …\nCreate an iterator over all <code>(key bytes, child pointers)</code> in …\nThe full key that the <code>value</code> was stored with.\nReturns a shared reference to the key contained by this …\nPointer to the leaf if the prefix was reconstructed\nSearch through this node for a child node that corresponds …\nCompares the compressed path of a node with the key and …\nHow many bytes were matched\nHow many bytes were matched\nHow many bytes were matched\nHow many bytes were matched\nHow many bytes were matched\nCheck that the provided full key is the same one as the …\nReturns the maximum child pointer from this node and it’…\nReturns the minimum child pointer from this node and it’…\nConstruct a new opaque node pointer from an existing …\nCreate a safe pointer to a <code>Node</code>.\nPointer to the next leaf node in the trie. If the value is …\nRetrieve the runtime node type information.\nTest the given key against the inner node header prefix by …\nValue of the byte that made it not match\nValue of the byte that made it not match.\nPointer to the previous leaf node in the trie. If the …\nCreate an iterator over a subset of …\nReads the Node from self without moving it. This leaves …\nRead the prefix as a whole, by reconstructing it if …\nAttempt to remove a child pointer at the key fragment from …\nThis function removes this leaf node from its linked list.\nMoves <code>new_value</code> into the referenced <code>dest</code>, returning the …\nInsert the leaf node pointed to by <code>this_ptr</code> into the …\nReturn true if an <code>InnerNode</code> with the given <code>NodeType</code> and …\nShrink this node into the next smaller class, copying over …\nCheck that the key starts with the given slice.\nCast this opaque pointer type an enum that contains a …\nConvert this node pointer with node type information into …\nCast node pointer back to an opaque version, losing type …\nAcquires the underlying *mut pointer.\nThe upper bound on the number of child nodes that this …\nThe leaf value.\nReturns a mutable reference to the value contained by this …\nReturns a shared reference to the value contained by this …\nRegister that the search procedure passed an inner node, …\nCreate a new leaf node with the given value and no …\nWrite a child pointer with key fragment to this inner node.\nThe key byte which selects the leaf node when used as …\nThe key byte which selects the leaf node when used as …\nA pointer to the grandparent node.\nA pointer to the root node of the tree.\nA pointer to the parent node.\nThe key byte which selects the parent node when used as …\nThe common header for all inner nodes\nThis type represents the contents of an <code>InnerNode</code> prefix, …\nMinimum between <code>Self::prefix_len</code> and <code>PREFIX_LEN</code>.\nSet the length of the prefix to 0 and returns a copy of the\nDecrements the number of children\nCreate a new <code>Header</code> for an empty node.\nReturns the argument unchanged.\nIncrements the number of children\nCalls <code>U::from(self)</code>.\nLeft trim by <code>len</code>, copies the remaining data to the …\nRemove the <code>len</code> length starting portion of this header’s …\nReturn the number of children of this node.\nNumber of children of this inner node. This field has no …\nThe key prefix for this node.\nGet the number of bytes in the prefix.\nNumber of bytes used by the prefix\nAppend <code>new</code> to the prefix and sums <code>new_len</code> to the prefix …\nRead the initialized portion of the prefix present in the …\nReset the number of children to 0.\nNode that references between 49 and 256 children\nAn array that directly maps a key byte (as index) to a …\nThe common node fields.\nA placeholder index value that indicates that the index is …\nNode that references between 17 and 49 children\nA restricted index only valid from 0 to LIMIT - 1.\nThe error type returned when attempting to construct an …\nAn array that maps key bytes (as the index) to the index …\nFor each element in this array, it is assumed to be …\nThe common node fields.\nReturn the initialized portions of the child pointer array.\nReturn true if the given index is the empty sentinel value\nIn an already existing key fragment\nNode that references between 5 and 16 children\nNode that references between 2 and 4 children\nNode type that has a compact representation for key bytes …\nIterator type for an <code>InnerNodeCompressed</code>\nAs the last key fragment\nCommon methods for searching in an <code>InnerNodeCompressed</code>\nShift the key fragments to the right\nWhere a write should happen inside the node\nGrows or shrinks the node\nAn array that contains the child data.\nAn array that contains the child data.\nAn array that contains the child data.\nFind the write point for <code>key_fragment</code>\nReturns the argument unchanged.\nTransform node into a <code>InnerNode48</code>\nThe common node fields.\nThe common node fields.\nThe common node fields.\nReturn the initialized portions of the keys and child …\nGet an iterator over the keys and values of the node\nGet an iterator over a range of keys and values of the …\nCalls <code>U::from(self)</code>.\nAn array that contains single key bytes in the same index …\nAn array that contains single key bytes in the same index …\nAn array that contains single key bytes in the same index …\nGet the index of the child if it exists\nGeneralized version of <code>InnerNode::lookup_child</code> for …\nRemoves child if it exists\nWrites a child to the node without bounds check or order\nWrites a child to the node by check the order of insertion\nWrites a child to the node without bounds check or order\nThis trait is used to seal other traits, such that they …\nA visitor of the radix trie that will print the tree in “…\nSettings which customize the output of the <code>DotPrinter</code> …\nThe length of the tree is not 0, even though the root is …\nStatistics for inner nodes\nA portion of an entire key that should uniquely identify …\nThere is a leaf node with a sibling pointer where the …\nStatistics for inner nodes\nA loop was observed between nodes\nAn issue with the well-formed-ness of the tree. See the …\nThe type of value that the visitor produces.\nThe expected key prefix did not match the actual prefix …\nCollection of stats about the number of nodes types …\nA visitor of the radix tree which collects statistics …\nThe <code>Visitable</code> trait allows <code>Visitor</code>s to traverse the …\nThe <code>Visitor</code> trait allows creating new operations on the …\nA visitor of the radix tree which checks that the tree is …\nThis struct contains some simple stats collected from the …\nAn inner node had an incorrect number of children\nThere is a leaf node which has incorrect values for either …\nPrint the byte representation of the given value as …\nCombine two instances of the <code>Self::Output</code> type for this …\nThe number of occurrences\nThe number of occurrences\nPrint a given value using the <code>Debug::fmt</code> implementation.\nProduce the default value of the <code>Self::Output</code> type.\nAdd node address to output in graphs\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of <code>LeafNode</code>s present in the tree.\nMaximum prefix length in bytes\nTotal memory usage in bytes\nTotal memory usage\nStats for <code>InnerNode16</code>s\nStats for <code>InnerNode256</code>s\nStats for <code>InnerNode4</code>s\nStats for <code>InnerNode48</code>s\nPrint the string “[null]”.\nThe number of inner node in the trie.\nThe number of leaf nodes in the trie.\nSum of all used prefix length capped to the maximum number …\nThe sum of bytes of keys stored in the tree.\nSum of all used prefix length\nThe number of used slots in inner nodes\nThis function provides the default traversal behavior for …\nSum of all header prefix lengths\nThe total number of slots in inner nodes\nStats for the whole tree\nVisit a <code>LeafNode</code>.\nVisit a <code>InnerNode16</code>.\nVisit a <code>InnerNode256</code>.\nVisit a <code>InnerNode4</code>.\nVisit a <code>InnerNode48</code>.\nThis function will traverse the implementing type and …\nThe actual <code>next</code> pointer value\nThe actual ordering (either <code>Ordering::Greater</code> or …\nThe actual <code>previous</code> pointer value\nThe entire key\nThe expected <code>next</code> pointer value\nThe expected ordering (either <code>Ordering::Greater</code> or …\nThe expected key prefix\nThe expected <code>previous</code> pointer value\nThe key prefix when the node was first observed\nThe type of the inner node (InnerNode4, InnerNode16, etc)\nThe key prefix identifying the inner node\nThe key prefix when the node was observed a second time\nThe key bytes of the leaf node that was out of order\nThe key bytes of the broken leaf node\nThe node that was observed more than once while traversing …\nThe number of children found at the inner node\nThe key bytes of the sibling leaf node\nA visitor of the radix trie that will print the tree in “…\nSettings which customize the output of the <code>DotPrinter</code> …\nPrint the byte representation of the given value as …\nPrint a given value using the <code>Debug::fmt</code> implementation.\nAdd node address to output in graphs\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPrint the string “[null]”.\nWrite the dot-format of the given tree to the given output.\nWrite the dot-format of the given tree to the given output.\nWrite the dot-format of the given tree to the given output.\nStatistics for inner nodes\nStatistics for inner nodes\nCollection of stats about the number of nodes types …\nA visitor of the radix tree which collects statistics …\nThe average prefix length but capped to the header prefix …\nThe average prefix length\nBytes used per entry in the tree (only inner node memory …\nBytes used per entry in the tree (total memory usage)\nRun the tree stats collection on the given tree, then …\nRun the tree stats collection on the given root node, then …\nThe number of occurrences\nThe number of occurrences\nThe average prefix length but capped to the header prefix …\nHow many free slots\nNumber of <code>LeafNode</code>s present in the tree.\nMaximum prefix length in bytes\nTotal memory usage in bytes\nTotal memory usage\nStats for <code>InnerNode16</code>s\nStats for <code>InnerNode256</code>s\nStats for <code>InnerNode4</code>s\nStats for <code>InnerNode48</code>s\nGets the node size in bytes, if the node count is 0, than …\nThe average prefix length but capped to the header prefix …\nPercentage of the maximum slots that is being used\nSum of all used prefix length capped to the maximum number …\nThe sum of bytes of keys stored in the tree.\nSum of all used prefix length\nThe number of used slots in inner nodes\nSum of all header prefix lengths\nTotal memory usage of the tree (inner nodes + leaf)\nThe total number of slots in inner nodes\nStats for the whole tree\nThe length of the tree is not 0, even though the root is …\nA portion of an entire key that should uniquely identify …\nThere is a leaf node with a sibling pointer where the …\nA loop was observed between nodes\nAn issue with the well-formed-ness of the tree. See the …\nThe expected key prefix did not match the actual prefix …\nA visitor of the radix tree which checks that the tree is …\nThis struct contains some simple stats collected from the …\nAn inner node had an incorrect number of children\nThere is a leaf node which has incorrect values for either …\nTraverse the given tree and check that it is well-formed. …\nTraverse the given tree and check that it is well-formed. …\nThe number of inner node in the trie.\nThe number of leaf nodes in the trie.\nThe total number of leaf nodes and inner nodes in the trie.\nThe actual <code>next</code> pointer value\nThe actual ordering (either <code>Ordering::Greater</code> or …\nThe actual <code>previous</code> pointer value\nThe entire key\nThe expected <code>next</code> pointer value\nThe expected ordering (either <code>Ordering::Greater</code> or …\nThe expected key prefix\nThe expected <code>previous</code> pointer value\nThe key prefix when the node was first observed\nThe type of the inner node (InnerNode4, InnerNode16, etc)\nThe key prefix identifying the inner node\nThe key prefix when the node was observed a second time\nThe key bytes of the leaf node that was out of order\nThe key bytes of the broken leaf node\nThe node that was observed more than once while traversing …\nThe number of children found at the inner node\nThe key bytes of the sibling leaf node\nWrites a length prefix into this hasher, as part of being …\nHints to the compiler that a branch condition is unlikely …\nAssuming all the elements are initialized, get a mutable …\nAssuming all the elements are initialized, get a slice to …\nThis module contains shim functions for strict-provenance …\nHints to the compiler that given path is cold, i.e., …\nThe ABI-required minimum alignment of the <code>P</code> type.\nA mask for data-carrying bits of the pointer.\nNumber of available bits of storage in the pointer.\nA mask for the non-data-carrying bits of the pointer.\nA non-null pointer type which carries several bits of …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new tagged pointer from a possibly null pointer.\nCreate a new non-null tagged pointer without verifying …\nCreate a new tagged pointer and immediately set data on it.\nUpdate the data this tagged pointer carries to a new value.\nConsume this tagged pointer and produce the data it …\nConsume this tagged pointer and produce a raw mutable …")